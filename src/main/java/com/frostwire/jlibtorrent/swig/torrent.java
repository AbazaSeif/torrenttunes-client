/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.6
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package com.frostwire.jlibtorrent.swig;

public class torrent {
  private long swigCPtr;
  protected boolean swigCMemOwn;

  protected torrent(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  protected static long getCPtr(torrent obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        libtorrent_jni.delete_torrent(swigCPtr);
      }
      swigCPtr = 0;
    }
  }

  public sha1_hash info_hash() {
    return new sha1_hash(libtorrent_jni.torrent_info_hash(swigCPtr, this), false);
  }

  public boolean is_deleted() {
    return libtorrent_jni.torrent_is_deleted(swigCPtr, this);
  }

  public void start(add_torrent_params p) {
    libtorrent_jni.torrent_start(swigCPtr, this, add_torrent_params.getCPtr(p), p);
  }

  public void start_download_url() {
    libtorrent_jni.torrent_start_download_url(swigCPtr, this);
  }

  public int current_stats_state() {
    return libtorrent_jni.torrent_current_stats_state(swigCPtr, this);
  }

  public void add_extension(torrent_plugin arg0) {
    libtorrent_jni.torrent_add_extension(swigCPtr, this, torrent_plugin.getCPtr(arg0), arg0);
  }

  public void remove_extension(torrent_plugin arg0) {
    libtorrent_jni.torrent_remove_extension(swigCPtr, this, torrent_plugin.getCPtr(arg0), arg0);
  }

  public void notify_extension_add_peer(tcp_endpoint ip, int src, int flags) {
    libtorrent_jni.torrent_notify_extension_add_peer(swigCPtr, this, tcp_endpoint.getCPtr(ip), ip, src, flags);
  }

  public peer_connection find_lowest_ranking_peer() {
    long cPtr = libtorrent_jni.torrent_find_lowest_ranking_peer(swigCPtr, this);
    return (cPtr == 0) ? null : new peer_connection(cPtr, true);
  }

  public void init() {
    libtorrent_jni.torrent_init(swigCPtr, this);
  }

  public boolean need_loaded() {
    return libtorrent_jni.torrent_need_loaded(swigCPtr, this);
  }

  public void unload() {
    libtorrent_jni.torrent_unload(swigCPtr, this);
  }

  public boolean load(char_vector buffer) {
    return libtorrent_jni.torrent_load(swigCPtr, this, char_vector.getCPtr(buffer), buffer);
  }

  public boolean is_pinned() {
    return libtorrent_jni.torrent_is_pinned(swigCPtr, this);
  }

  public void set_pinned(boolean p) {
    libtorrent_jni.torrent_set_pinned(swigCPtr, this, p);
  }

  public boolean is_loaded() {
    return libtorrent_jni.torrent_is_loaded(swigCPtr, this);
  }

  public boolean should_be_loaded() {
    return libtorrent_jni.torrent_should_be_loaded(swigCPtr, this);
  }

  public bt_peer_connection find_introducer(tcp_endpoint ep) {
    long cPtr = libtorrent_jni.torrent_find_introducer(swigCPtr, this, tcp_endpoint.getCPtr(ep), ep);
    return (cPtr == 0) ? null : new bt_peer_connection(cPtr, true);
  }

  public bt_peer_connection find_peer(tcp_endpoint ep) {
    long cPtr = libtorrent_jni.torrent_find_peer__SWIG_0(swigCPtr, this, tcp_endpoint.getCPtr(ep), ep);
    return (cPtr == 0) ? null : new bt_peer_connection(cPtr, true);
  }

  public peer_connection find_peer(sha1_hash pid) {
    long cPtr = libtorrent_jni.torrent_find_peer__SWIG_1(swigCPtr, this, sha1_hash.getCPtr(pid), pid);
    return (cPtr == 0) ? null : new peer_connection(cPtr, true);
  }

  public void files_checked() {
    libtorrent_jni.torrent_files_checked(swigCPtr, this);
  }

  public void start_checking() {
    libtorrent_jni.torrent_start_checking(swigCPtr, this);
  }

  public void start_announcing() {
    libtorrent_jni.torrent_start_announcing(swigCPtr, this);
  }

  public void stop_announcing() {
    libtorrent_jni.torrent_stop_announcing(swigCPtr, this);
  }

  public void send_share_mode() {
    libtorrent_jni.torrent_send_share_mode(swigCPtr, this);
  }

  public void send_upload_only() {
    libtorrent_jni.torrent_send_upload_only(swigCPtr, this);
  }

  public void set_share_mode(boolean s) {
    libtorrent_jni.torrent_set_share_mode(swigCPtr, this, s);
  }

  public boolean share_mode() {
    return libtorrent_jni.torrent_share_mode(swigCPtr, this);
  }

  public boolean graceful_pause() {
    return libtorrent_jni.torrent_graceful_pause(swigCPtr, this);
  }

  public void set_upload_mode(boolean b) {
    libtorrent_jni.torrent_set_upload_mode(swigCPtr, this, b);
  }

  public boolean upload_mode() {
    return libtorrent_jni.torrent_upload_mode(swigCPtr, this);
  }

  public boolean is_upload_only() {
    return libtorrent_jni.torrent_is_upload_only(swigCPtr, this);
  }

  public int seed_rank(session_settings s) {
    return libtorrent_jni.torrent_seed_rank(swigCPtr, this, session_settings.getCPtr(s), s);
  }

  public void add_piece(int piece, String data, int flags) {
    libtorrent_jni.torrent_add_piece__SWIG_0(swigCPtr, this, piece, data, flags);
  }

  public void add_piece(int piece, String data) {
    libtorrent_jni.torrent_add_piece__SWIG_1(swigCPtr, this, piece, data);
  }

  public void schedule_storage_tick() {
    libtorrent_jni.torrent_schedule_storage_tick(swigCPtr, this);
  }

  public void set_progress_ppm(int p) {
    libtorrent_jni.torrent_set_progress_ppm(swigCPtr, this, p);
  }

  static public class read_piece_struct {
    private long swigCPtr;
    protected boolean swigCMemOwn;
  
    protected read_piece_struct(long cPtr, boolean cMemoryOwn) {
      swigCMemOwn = cMemoryOwn;
      swigCPtr = cPtr;
    }
  
    protected static long getCPtr(read_piece_struct obj) {
      return (obj == null) ? 0 : obj.swigCPtr;
    }
  
    protected void finalize() {
      delete();
    }
  
    public synchronized void delete() {
      if (swigCPtr != 0) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          libtorrent_jni.delete_torrent_read_piece_struct(swigCPtr);
        }
        swigCPtr = 0;
      }
    }
  
    public void setBlocks_left(int value) {
      libtorrent_jni.torrent_read_piece_struct_blocks_left_set(swigCPtr, this, value);
    }
  
    public int getBlocks_left() {
      return libtorrent_jni.torrent_read_piece_struct_blocks_left_get(swigCPtr, this);
    }
  
    public void setFail(boolean value) {
      libtorrent_jni.torrent_read_piece_struct_fail_set(swigCPtr, this, value);
    }
  
    public boolean getFail() {
      return libtorrent_jni.torrent_read_piece_struct_fail_get(swigCPtr, this);
    }
  
    public void setError(error_code value) {
      libtorrent_jni.torrent_read_piece_struct_error_set(swigCPtr, this, error_code.getCPtr(value), value);
    }
  
    public error_code getError() {
      long cPtr = libtorrent_jni.torrent_read_piece_struct_error_get(swigCPtr, this);
      return (cPtr == 0) ? null : new error_code(cPtr, false);
    }
  
    public read_piece_struct() {
      this(libtorrent_jni.new_torrent_read_piece_struct(), true);
    }
  
  }

  public void read_piece(int piece) {
    libtorrent_jni.torrent_read_piece(swigCPtr, this, piece);
  }

  public storage_mode_t storage_mode() {
    return storage_mode_t.swigToEnum(libtorrent_jni.torrent_storage_mode(swigCPtr, this));
  }

  public void abort() {
    libtorrent_jni.torrent_abort(swigCPtr, this);
  }

  public boolean is_aborted() {
    return libtorrent_jni.torrent_is_aborted(swigCPtr, this);
  }

  public void new_external_ip() {
    libtorrent_jni.torrent_new_external_ip(swigCPtr, this);
  }

  public torrent_status.state_t state() {
    return torrent_status.state_t.swigToEnum(libtorrent_jni.torrent_state(swigCPtr, this));
  }

  public void set_state(torrent_status.state_t s) {
    libtorrent_jni.torrent_set_state(swigCPtr, this, s.swigValue());
  }

  public session_settings settings() {
    return new session_settings(libtorrent_jni.torrent_settings(swigCPtr, this), false);
  }

  public void set_sequential_download(boolean sd) {
    libtorrent_jni.torrent_set_sequential_download(swigCPtr, this, sd);
  }

  public boolean is_sequential_download() {
    return libtorrent_jni.torrent_is_sequential_download(swigCPtr, this);
  }

  public void queue_up() {
    libtorrent_jni.torrent_queue_up(swigCPtr, this);
  }

  public void queue_down() {
    libtorrent_jni.torrent_queue_down(swigCPtr, this);
  }

  public void set_queue_position(int p) {
    libtorrent_jni.torrent_set_queue_position(swigCPtr, this, p);
  }

  public int queue_position() {
    return libtorrent_jni.torrent_queue_position(swigCPtr, this);
  }

  public void set_queue_position_impl(int p) {
    libtorrent_jni.torrent_set_queue_position_impl(swigCPtr, this, p);
  }

  public void second_tick(int tick_interval_ms, int residual) {
    libtorrent_jni.torrent_second_tick(swigCPtr, this, tick_interval_ms, residual);
  }

  public void maybe_connect_web_seeds() {
    libtorrent_jni.torrent_maybe_connect_web_seeds(swigCPtr, this);
  }

  public String name() {
    return libtorrent_jni.torrent_name(swigCPtr, this);
  }

  public stat statistics() {
    return new stat(libtorrent_jni.torrent_statistics(swigCPtr, this), true);
  }

  public long bytes_left() {
    return libtorrent_jni.torrent_bytes_left(swigCPtr, this);
  }

  public void bytes_done(torrent_status st, boolean accurate) {
    libtorrent_jni.torrent_bytes_done(swigCPtr, this, torrent_status.getCPtr(st), st, accurate);
  }

  public long quantized_bytes_done() {
    return libtorrent_jni.torrent_quantized_bytes_done(swigCPtr, this);
  }

  public void sent_bytes(int bytes_payload, int bytes_protocol) {
    libtorrent_jni.torrent_sent_bytes(swigCPtr, this, bytes_payload, bytes_protocol);
  }

  public void received_bytes(int bytes_payload, int bytes_protocol) {
    libtorrent_jni.torrent_received_bytes(swigCPtr, this, bytes_payload, bytes_protocol);
  }

  public void trancieve_ip_packet(int bytes, boolean ipv6) {
    libtorrent_jni.torrent_trancieve_ip_packet(swigCPtr, this, bytes, ipv6);
  }

  public void sent_syn(boolean ipv6) {
    libtorrent_jni.torrent_sent_syn(swigCPtr, this, ipv6);
  }

  public void received_synack(boolean ipv6) {
    libtorrent_jni.torrent_received_synack(swigCPtr, this, ipv6);
  }

  public void port_filter_updated() {
    libtorrent_jni.torrent_port_filter_updated(swigCPtr, this);
  }

  public String resolve_filename(int file) {
    return libtorrent_jni.torrent_resolve_filename(swigCPtr, this, file);
  }

  public void clear_error() {
    libtorrent_jni.torrent_clear_error(swigCPtr, this);
  }

  public void set_error(error_code ec, int file) {
    libtorrent_jni.torrent_set_error(swigCPtr, this, error_code.getCPtr(ec), ec, file);
  }

  public boolean has_error() {
    return libtorrent_jni.torrent_has_error(swigCPtr, this);
  }

  public error_code error() {
    return new error_code(libtorrent_jni.torrent_error(swigCPtr, this), true);
  }

  public void flush_cache() {
    libtorrent_jni.torrent_flush_cache(swigCPtr, this);
  }

  public void pause(boolean graceful) {
    libtorrent_jni.torrent_pause__SWIG_0(swigCPtr, this, graceful);
  }

  public void pause() {
    libtorrent_jni.torrent_pause__SWIG_1(swigCPtr, this);
  }

  public void resume() {
    libtorrent_jni.torrent_resume(swigCPtr, this);
  }

  public void set_allow_peers(boolean b, boolean graceful_pause) {
    libtorrent_jni.torrent_set_allow_peers__SWIG_0(swigCPtr, this, b, graceful_pause);
  }

  public void set_allow_peers(boolean b) {
    libtorrent_jni.torrent_set_allow_peers__SWIG_1(swigCPtr, this, b);
  }

  public void set_announce_to_dht(boolean b) {
    libtorrent_jni.torrent_set_announce_to_dht(swigCPtr, this, b);
  }

  public void set_announce_to_trackers(boolean b) {
    libtorrent_jni.torrent_set_announce_to_trackers(swigCPtr, this, b);
  }

  public void set_announce_to_lsd(boolean b) {
    libtorrent_jni.torrent_set_announce_to_lsd(swigCPtr, this, b);
  }

  public int started() {
    return libtorrent_jni.torrent_started(swigCPtr, this);
  }

  public void step_session_time(int seconds) {
    libtorrent_jni.torrent_step_session_time(swigCPtr, this, seconds);
  }

  public void do_pause() {
    libtorrent_jni.torrent_do_pause(swigCPtr, this);
  }

  public void do_resume() {
    libtorrent_jni.torrent_do_resume(swigCPtr, this);
  }

  public int finished_time() {
    return libtorrent_jni.torrent_finished_time(swigCPtr, this);
  }

  public int active_time() {
    return libtorrent_jni.torrent_active_time(swigCPtr, this);
  }

  public int seeding_time() {
    return libtorrent_jni.torrent_seeding_time(swigCPtr, this);
  }

  public boolean is_paused() {
    return libtorrent_jni.torrent_is_paused(swigCPtr, this);
  }

  public boolean allows_peers() {
    return libtorrent_jni.torrent_allows_peers(swigCPtr, this);
  }

  public boolean is_torrent_paused() {
    return libtorrent_jni.torrent_is_torrent_paused(swigCPtr, this);
  }

  public void force_recheck() {
    libtorrent_jni.torrent_force_recheck(swigCPtr, this);
  }

  public void save_resume_data(int flags) {
    libtorrent_jni.torrent_save_resume_data(swigCPtr, this, flags);
  }

  public boolean do_async_save_resume_data() {
    return libtorrent_jni.torrent_do_async_save_resume_data(swigCPtr, this);
  }

  public boolean need_save_resume_data() {
    return libtorrent_jni.torrent_need_save_resume_data(swigCPtr, this);
  }

  public boolean is_auto_managed() {
    return libtorrent_jni.torrent_is_auto_managed(swigCPtr, this);
  }

  public void auto_managed(boolean a) {
    libtorrent_jni.torrent_auto_managed(swigCPtr, this, a);
  }

  public boolean should_check_files() {
    return libtorrent_jni.torrent_should_check_files(swigCPtr, this);
  }

  public boolean delete_files() {
    return libtorrent_jni.torrent_delete_files(swigCPtr, this);
  }

  public void peers_erased(torrent_peer_ptr_vector peers) {
    libtorrent_jni.torrent_peers_erased(swigCPtr, this, torrent_peer_ptr_vector.getCPtr(peers), peers);
  }

  public void filter_piece(int index, boolean filter) {
    libtorrent_jni.torrent_filter_piece(swigCPtr, this, index, filter);
  }

  public void filter_pieces(bool_vector bitmask) {
    libtorrent_jni.torrent_filter_pieces(swigCPtr, this, bool_vector.getCPtr(bitmask), bitmask);
  }

  public boolean is_piece_filtered(int index) {
    return libtorrent_jni.torrent_is_piece_filtered(swigCPtr, this, index);
  }

  public void filtered_pieces(bool_vector bitmask) {
    libtorrent_jni.torrent_filtered_pieces(swigCPtr, this, bool_vector.getCPtr(bitmask), bitmask);
  }

  public void filter_files(bool_vector files) {
    libtorrent_jni.torrent_filter_files(swigCPtr, this, bool_vector.getCPtr(files), files);
  }

  public void file_progress(float_vector fp) {
    libtorrent_jni.torrent_file_progress__SWIG_0(swigCPtr, this, float_vector.getCPtr(fp), fp);
  }

  public void piece_availability(int_vector avail) {
    libtorrent_jni.torrent_piece_availability(swigCPtr, this, int_vector.getCPtr(avail), avail);
  }

  public void set_piece_priority(int index, int priority) {
    libtorrent_jni.torrent_set_piece_priority(swigCPtr, this, index, priority);
  }

  public int piece_priority(int index) {
    return libtorrent_jni.torrent_piece_priority(swigCPtr, this, index);
  }

  public void prioritize_pieces(int_vector pieces) {
    libtorrent_jni.torrent_prioritize_pieces(swigCPtr, this, int_vector.getCPtr(pieces), pieces);
  }

  public void prioritize_piece_list(int_int_pair_vector pieces) {
    libtorrent_jni.torrent_prioritize_piece_list(swigCPtr, this, int_int_pair_vector.getCPtr(pieces), pieces);
  }

  public void piece_priorities(int_vector arg0) {
    libtorrent_jni.torrent_piece_priorities(swigCPtr, this, int_vector.getCPtr(arg0), arg0);
  }

  public void set_file_priority(int index, int priority) {
    libtorrent_jni.torrent_set_file_priority(swigCPtr, this, index, priority);
  }

  public int file_priority(int index) {
    return libtorrent_jni.torrent_file_priority(swigCPtr, this, index);
  }

  public void on_file_priority() {
    libtorrent_jni.torrent_on_file_priority(swigCPtr, this);
  }

  public void prioritize_files(int_vector files) {
    libtorrent_jni.torrent_prioritize_files(swigCPtr, this, int_vector.getCPtr(files), files);
  }

  public void file_priorities(int_vector arg0) {
    libtorrent_jni.torrent_file_priorities(swigCPtr, this, int_vector.getCPtr(arg0), arg0);
  }

  public void cancel_non_critical() {
    libtorrent_jni.torrent_cancel_non_critical(swigCPtr, this);
  }

  public void set_piece_deadline(int piece, int t, int flags) {
    libtorrent_jni.torrent_set_piece_deadline(swigCPtr, this, piece, t, flags);
  }

  public void reset_piece_deadline(int piece) {
    libtorrent_jni.torrent_reset_piece_deadline(swigCPtr, this, piece);
  }

  public void clear_time_critical() {
    libtorrent_jni.torrent_clear_time_critical(swigCPtr, this);
  }

  public void update_piece_priorities() {
    libtorrent_jni.torrent_update_piece_priorities(swigCPtr, this);
  }

  public void status(torrent_status st, long flags) {
    libtorrent_jni.torrent_status(swigCPtr, this, torrent_status.getCPtr(st), st, flags);
  }

  public void state_updated() {
    libtorrent_jni.torrent_state_updated(swigCPtr, this);
  }

  public void file_progress(int64_vector fp, int flags) {
    libtorrent_jni.torrent_file_progress__SWIG_1(swigCPtr, this, int64_vector.getCPtr(fp), fp, flags);
  }

  public void file_progress(int64_vector fp) {
    libtorrent_jni.torrent_file_progress__SWIG_2(swigCPtr, this, int64_vector.getCPtr(fp), fp);
  }

  public boolean connect_to_peer(torrent_peer peerinfo, boolean ignore_limit) {
    return libtorrent_jni.torrent_connect_to_peer__SWIG_0(swigCPtr, this, torrent_peer.getCPtr(peerinfo), peerinfo, ignore_limit);
  }

  public boolean connect_to_peer(torrent_peer peerinfo) {
    return libtorrent_jni.torrent_connect_to_peer__SWIG_1(swigCPtr, this, torrent_peer.getCPtr(peerinfo), peerinfo);
  }

  public int priority() {
    return libtorrent_jni.torrent_priority(swigCPtr, this);
  }

  public void set_priority(int prio) {
    libtorrent_jni.torrent_set_priority(swigCPtr, this, prio);
  }

  public void resolve_countries(boolean r) {
    libtorrent_jni.torrent_resolve_countries(swigCPtr, this, r);
  }

  public boolean resolving_countries() {
    return libtorrent_jni.torrent_resolving_countries(swigCPtr, this);
  }

  public void set_upload_limit(int limit) {
    libtorrent_jni.torrent_set_upload_limit(swigCPtr, this, limit);
  }

  public int upload_limit() {
    return libtorrent_jni.torrent_upload_limit(swigCPtr, this);
  }

  public void set_download_limit(int limit) {
    libtorrent_jni.torrent_set_download_limit(swigCPtr, this, limit);
  }

  public int download_limit() {
    return libtorrent_jni.torrent_download_limit(swigCPtr, this);
  }

  public short peer_class() {
    return libtorrent_jni.torrent_peer_class(swigCPtr, this);
  }

  public void set_max_uploads(int limit, boolean state_update) {
    libtorrent_jni.torrent_set_max_uploads__SWIG_0(swigCPtr, this, limit, state_update);
  }

  public void set_max_uploads(int limit) {
    libtorrent_jni.torrent_set_max_uploads__SWIG_1(swigCPtr, this, limit);
  }

  public int max_uploads() {
    return libtorrent_jni.torrent_max_uploads(swigCPtr, this);
  }

  public void set_max_connections(int limit, boolean state_update) {
    libtorrent_jni.torrent_set_max_connections__SWIG_0(swigCPtr, this, limit, state_update);
  }

  public void set_max_connections(int limit) {
    libtorrent_jni.torrent_set_max_connections__SWIG_1(swigCPtr, this, limit);
  }

  public int max_connections() {
    return libtorrent_jni.torrent_max_connections(swigCPtr, this);
  }

  public void add_web_seed(String url, web_seed_entry.type_t type) {
    libtorrent_jni.torrent_add_web_seed__SWIG_0(swigCPtr, this, url, type.swigValue());
  }

  public void add_web_seed(String url, web_seed_entry.type_t type, String auth, string_string_pair_vector extra_headers) {
    libtorrent_jni.torrent_add_web_seed__SWIG_1(swigCPtr, this, url, type.swigValue(), auth, string_string_pair_vector.getCPtr(extra_headers), extra_headers);
  }

  public void disconnect_web_seed(peer_connection p) {
    libtorrent_jni.torrent_disconnect_web_seed(swigCPtr, this, peer_connection.getCPtr(p), p);
  }

  public void retry_web_seed(peer_connection p, int retry) {
    libtorrent_jni.torrent_retry_web_seed__SWIG_0(swigCPtr, this, peer_connection.getCPtr(p), p, retry);
  }

  public void retry_web_seed(peer_connection p) {
    libtorrent_jni.torrent_retry_web_seed__SWIG_1(swigCPtr, this, peer_connection.getCPtr(p), p);
  }

  public boolean free_upload_slots() {
    return libtorrent_jni.torrent_free_upload_slots(swigCPtr, this);
  }

  public boolean choke_peer(peer_connection c) {
    return libtorrent_jni.torrent_choke_peer(swigCPtr, this, peer_connection.getCPtr(c), c);
  }

  public boolean unchoke_peer(peer_connection c, boolean optimistic) {
    return libtorrent_jni.torrent_unchoke_peer__SWIG_0(swigCPtr, this, peer_connection.getCPtr(c), c, optimistic);
  }

  public boolean unchoke_peer(peer_connection c) {
    return libtorrent_jni.torrent_unchoke_peer__SWIG_1(swigCPtr, this, peer_connection.getCPtr(c), c);
  }

  public void trigger_unchoke() {
    libtorrent_jni.torrent_trigger_unchoke(swigCPtr, this);
  }

  public void trigger_optimistic_unchoke() {
    libtorrent_jni.torrent_trigger_optimistic_unchoke(swigCPtr, this);
  }

  public boolean attach_peer(peer_connection p) {
    return libtorrent_jni.torrent_attach_peer(swigCPtr, this, peer_connection.getCPtr(p), p);
  }

  public void remove_peer(peer_connection p) {
    libtorrent_jni.torrent_remove_peer(swigCPtr, this, peer_connection.getCPtr(p), p);
  }

  public boolean want_tick() {
    return libtorrent_jni.torrent_want_tick(swigCPtr, this);
  }

  public void update_want_tick() {
    libtorrent_jni.torrent_update_want_tick(swigCPtr, this);
  }

  public void update_state_list() {
    libtorrent_jni.torrent_update_state_list(swigCPtr, this);
  }

  public boolean want_peers() {
    return libtorrent_jni.torrent_want_peers(swigCPtr, this);
  }

  public boolean want_peers_download() {
    return libtorrent_jni.torrent_want_peers_download(swigCPtr, this);
  }

  public boolean want_peers_finished() {
    return libtorrent_jni.torrent_want_peers_finished(swigCPtr, this);
  }

  public void update_want_peers() {
    libtorrent_jni.torrent_update_want_peers(swigCPtr, this);
  }

  public void update_want_scrape() {
    libtorrent_jni.torrent_update_want_scrape(swigCPtr, this);
  }

  public void update_gauge() {
    libtorrent_jni.torrent_update_gauge(swigCPtr, this);
  }

  public boolean try_connect_peer() {
    return libtorrent_jni.torrent_try_connect_peer(swigCPtr, this);
  }

  public torrent_peer add_peer(tcp_endpoint adr, int source, int flags) {
    long cPtr = libtorrent_jni.torrent_add_peer__SWIG_0(swigCPtr, this, tcp_endpoint.getCPtr(adr), adr, source, flags);
    return (cPtr == 0) ? null : new torrent_peer(cPtr, false);
  }

  public torrent_peer add_peer(tcp_endpoint adr, int source) {
    long cPtr = libtorrent_jni.torrent_add_peer__SWIG_1(swigCPtr, this, tcp_endpoint.getCPtr(adr), adr, source);
    return (cPtr == 0) ? null : new torrent_peer(cPtr, false);
  }

  public boolean ban_peer(torrent_peer tp) {
    return libtorrent_jni.torrent_ban_peer(swigCPtr, this, torrent_peer.getCPtr(tp), tp);
  }

  public void update_peer_port(int port, torrent_peer p, int src) {
    libtorrent_jni.torrent_update_peer_port(swigCPtr, this, port, torrent_peer.getCPtr(p), p, src);
  }

  public void set_seed(torrent_peer p, boolean s) {
    libtorrent_jni.torrent_set_seed(swigCPtr, this, torrent_peer.getCPtr(p), p, s);
  }

  public void clear_failcount(torrent_peer p) {
    libtorrent_jni.torrent_clear_failcount(swigCPtr, this, torrent_peer.getCPtr(p), p);
  }

  public int num_peers() {
    return libtorrent_jni.torrent_num_peers(swigCPtr, this);
  }

  public int num_seeds() {
    return libtorrent_jni.torrent_num_seeds(swigCPtr, this);
  }

  public int num_downloaders() {
    return libtorrent_jni.torrent_num_downloaders(swigCPtr, this);
  }

  public void get_full_peer_list(peer_list_entry_vector v) {
    libtorrent_jni.torrent_get_full_peer_list(swigCPtr, this, peer_list_entry_vector.getCPtr(v), v);
  }

  public void get_peer_info(peer_info_vector v) {
    libtorrent_jni.torrent_get_peer_info(swigCPtr, this, peer_info_vector.getCPtr(v), v);
  }

  public void get_download_queue(partial_piece_info_vector queue) {
    libtorrent_jni.torrent_get_download_queue(swigCPtr, this, partial_piece_info_vector.getCPtr(queue), queue);
  }

  public void refresh_explicit_cache(int cache_size) {
    libtorrent_jni.torrent_refresh_explicit_cache(swigCPtr, this, cache_size);
  }

  public void add_suggest_piece(int piece) {
    libtorrent_jni.torrent_add_suggest_piece(swigCPtr, this, piece);
  }

  public void update_suggest_piece(int index, int change) {
    libtorrent_jni.torrent_update_suggest_piece(swigCPtr, this, index, change);
  }

  public void update_auto_sequential() {
    libtorrent_jni.torrent_update_auto_sequential(swigCPtr, this);
  }

  public void refresh_suggest_pieces() {
    libtorrent_jni.torrent_refresh_suggest_pieces(swigCPtr, this);
  }

  public void do_refresh_suggest_pieces() {
    libtorrent_jni.torrent_do_refresh_suggest_pieces(swigCPtr, this);
  }

  public void tracker_request_error(tracker_request r, int response_code, error_code ec, String msg, int retry_interval) {
    libtorrent_jni.torrent_tracker_request_error(swigCPtr, this, tracker_request.getCPtr(r), r, response_code, error_code.getCPtr(ec), ec, msg, retry_interval);
  }

  public void tracker_warning(tracker_request req, String msg) {
    libtorrent_jni.torrent_tracker_warning(swigCPtr, this, tracker_request.getCPtr(req), req, msg);
  }

  public void tracker_scrape_response(tracker_request req, int complete, int incomplete, int downloaded, int downloaders) {
    libtorrent_jni.torrent_tracker_scrape_response(swigCPtr, this, tracker_request.getCPtr(req), req, complete, incomplete, downloaded, downloaders);
  }

  public void update_scrape_state() {
    libtorrent_jni.torrent_update_scrape_state(swigCPtr, this);
  }

  public String tracker_login() {
    return libtorrent_jni.torrent_tracker_login(swigCPtr, this);
  }

  public long tracker_key() {
    return libtorrent_jni.torrent_tracker_key(swigCPtr, this);
  }

  public void do_connect_boost() {
    libtorrent_jni.torrent_do_connect_boost(swigCPtr, this);
  }

  public high_resolution_clock.time_point next_announce() {
    return new high_resolution_clock.time_point(libtorrent_jni.torrent_next_announce(swigCPtr, this), true);
  }

  public void force_tracker_request(high_resolution_clock.time_point arg0, int tracker_idx) {
    libtorrent_jni.torrent_force_tracker_request(swigCPtr, this, high_resolution_clock.time_point.getCPtr(arg0), arg0, tracker_idx);
  }

  public void scrape_tracker() {
    libtorrent_jni.torrent_scrape_tracker(swigCPtr, this);
  }

  public void announce_with_tracker(short e, address bind_interface) {
    libtorrent_jni.torrent_announce_with_tracker__SWIG_0(swigCPtr, this, e, address.getCPtr(bind_interface), bind_interface);
  }

  public void announce_with_tracker(short e) {
    libtorrent_jni.torrent_announce_with_tracker__SWIG_1(swigCPtr, this, e);
  }

  public void announce_with_tracker() {
    libtorrent_jni.torrent_announce_with_tracker__SWIG_2(swigCPtr, this);
  }

  public int seconds_since_last_scrape() {
    return libtorrent_jni.torrent_seconds_since_last_scrape(swigCPtr, this);
  }

  public void dht_announce() {
    libtorrent_jni.torrent_dht_announce(swigCPtr, this);
  }

  public void set_tracker_login(String name, String pw) {
    libtorrent_jni.torrent_set_tracker_login(swigCPtr, this, name, pw);
  }

  public announce_entry find_tracker(tracker_request r) {
    long cPtr = libtorrent_jni.torrent_find_tracker(swigCPtr, this, tracker_request.getCPtr(r), r);
    return (cPtr == 0) ? null : new announce_entry(cPtr, false);
  }

  public void recalc_share_mode() {
    libtorrent_jni.torrent_recalc_share_mode(swigCPtr, this);
  }

  static public class suggest_piece_t {
    private long swigCPtr;
    protected boolean swigCMemOwn;
  
    protected suggest_piece_t(long cPtr, boolean cMemoryOwn) {
      swigCMemOwn = cMemoryOwn;
      swigCPtr = cPtr;
    }
  
    protected static long getCPtr(suggest_piece_t obj) {
      return (obj == null) ? 0 : obj.swigCPtr;
    }
  
    protected void finalize() {
      delete();
    }
  
    public synchronized void delete() {
      if (swigCPtr != 0) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          libtorrent_jni.delete_torrent_suggest_piece_t(swigCPtr);
        }
        swigCPtr = 0;
      }
    }
  
    public void setPiece_index(int value) {
      libtorrent_jni.torrent_suggest_piece_t_piece_index_set(swigCPtr, this, value);
    }
  
    public int getPiece_index() {
      return libtorrent_jni.torrent_suggest_piece_t_piece_index_get(swigCPtr, this);
    }
  
    public void setNum_peers(int value) {
      libtorrent_jni.torrent_suggest_piece_t_num_peers_set(swigCPtr, this, value);
    }
  
    public int getNum_peers() {
      return libtorrent_jni.torrent_suggest_piece_t_num_peers_get(swigCPtr, this);
    }
  
    public boolean op_lt(torrent.suggest_piece_t p) {
      return libtorrent_jni.torrent_suggest_piece_t_op_lt(swigCPtr, this, torrent.suggest_piece_t.getCPtr(p), p);
    }
  
    public suggest_piece_t() {
      this(libtorrent_jni.new_torrent_suggest_piece_t(), true);
    }
  
  }

  public suggest_piece_vector get_suggested_pieces() {
    return new suggest_piece_vector(libtorrent_jni.torrent_get_suggested_pieces(swigCPtr, this), false);
  }

  public boolean super_seeding() {
    return libtorrent_jni.torrent_super_seeding__SWIG_0(swigCPtr, this);
  }

  public void super_seeding(boolean on) {
    libtorrent_jni.torrent_super_seeding__SWIG_1(swigCPtr, this, on);
  }

  public int get_piece_to_super_seed(bitfield arg0) {
    return libtorrent_jni.torrent_get_piece_to_super_seed(swigCPtr, this, bitfield.getCPtr(arg0), arg0);
  }

  public boolean have_piece(int index) {
    return libtorrent_jni.torrent_have_piece(swigCPtr, this, index);
  }

  public boolean has_piece_passed(int index) {
    return libtorrent_jni.torrent_has_piece_passed(swigCPtr, this, index);
  }

  public boolean is_predictive_piece(int index) {
    return libtorrent_jni.torrent_is_predictive_piece(swigCPtr, this, index);
  }

  public void we_have(int index) {
    libtorrent_jni.torrent_we_have(swigCPtr, this, index);
  }

  public int num_have() {
    return libtorrent_jni.torrent_num_have(swigCPtr, this);
  }

  public int num_passed() {
    return libtorrent_jni.torrent_num_passed(swigCPtr, this);
  }

  public void peer_has(int index, peer_connection peer) {
    libtorrent_jni.torrent_peer_has__SWIG_0(swigCPtr, this, index, peer_connection.getCPtr(peer), peer);
  }

  public void peer_has(bitfield bits, peer_connection peer) {
    libtorrent_jni.torrent_peer_has__SWIG_1(swigCPtr, this, bitfield.getCPtr(bits), bits, peer_connection.getCPtr(peer), peer);
  }

  public void peer_has_all(peer_connection peer) {
    libtorrent_jni.torrent_peer_has_all(swigCPtr, this, peer_connection.getCPtr(peer), peer);
  }

  public void peer_lost(int index, peer_connection peer) {
    libtorrent_jni.torrent_peer_lost__SWIG_0(swigCPtr, this, index, peer_connection.getCPtr(peer), peer);
  }

  public void peer_lost(bitfield bits, peer_connection peer) {
    libtorrent_jni.torrent_peer_lost__SWIG_1(swigCPtr, this, bitfield.getCPtr(bits), bits, peer_connection.getCPtr(peer), peer);
  }

  public int block_size() {
    return libtorrent_jni.torrent_block_size(swigCPtr, this);
  }

  public void disconnect_all(error_code ec, operation_t op) {
    libtorrent_jni.torrent_disconnect_all(swigCPtr, this, error_code.getCPtr(ec), ec, op.swigValue());
  }

  public int disconnect_peers(int num, error_code ec) {
    return libtorrent_jni.torrent_disconnect_peers(swigCPtr, this, num, error_code.getCPtr(ec), ec);
  }

  public void maybe_done_flushing() {
    libtorrent_jni.torrent_maybe_done_flushing(swigCPtr, this);
  }

  public void completed() {
    libtorrent_jni.torrent_completed(swigCPtr, this);
  }

  public void on_inactivity_tick(error_code ec) {
    libtorrent_jni.torrent_on_inactivity_tick(swigCPtr, this, error_code.getCPtr(ec), ec);
  }

  public boolean is_inactive_internal() {
    return libtorrent_jni.torrent_is_inactive_internal(swigCPtr, this);
  }

  public void finished() {
    libtorrent_jni.torrent_finished(swigCPtr, this);
  }

  public void resume_download() {
    libtorrent_jni.torrent_resume_download(swigCPtr, this);
  }

  public void verify_piece(int piece) {
    libtorrent_jni.torrent_verify_piece(swigCPtr, this, piece);
  }

  public void peer_is_interesting(peer_connection c) {
    libtorrent_jni.torrent_peer_is_interesting(swigCPtr, this, peer_connection.getCPtr(c), c);
  }

  public void piece_passed(int index) {
    libtorrent_jni.torrent_piece_passed(swigCPtr, this, index);
  }

  public void piece_failed(int index) {
    libtorrent_jni.torrent_piece_failed(swigCPtr, this, index);
  }

  public void add_redundant_bytes(int b, torrent.wasted_reason_t reason) {
    libtorrent_jni.torrent_add_redundant_bytes(swigCPtr, this, b, reason.swigValue());
  }

  public void add_failed_bytes(int b) {
    libtorrent_jni.torrent_add_failed_bytes(swigCPtr, this, b);
  }

  public boolean is_seed() {
    return libtorrent_jni.torrent_is_seed(swigCPtr, this);
  }

  public boolean is_finished() {
    return libtorrent_jni.torrent_is_finished(swigCPtr, this);
  }

  public boolean is_inactive() {
    return libtorrent_jni.torrent_is_inactive(swigCPtr, this);
  }

  public String save_path() {
    return libtorrent_jni.torrent_save_path(swigCPtr, this);
  }

  public void need_picker() {
    libtorrent_jni.torrent_need_picker(swigCPtr, this);
  }

  public boolean has_picker() {
    return libtorrent_jni.torrent_has_picker(swigCPtr, this);
  }

  public void update_max_failcount() {
    libtorrent_jni.torrent_update_max_failcount(swigCPtr, this);
  }

  public int num_known_peers() {
    return libtorrent_jni.torrent_num_known_peers(swigCPtr, this);
  }

  public int num_connect_candidates() {
    return libtorrent_jni.torrent_num_connect_candidates(swigCPtr, this);
  }

  public boolean has_storage() {
    return libtorrent_jni.torrent_has_storage(swigCPtr, this);
  }

  public torrent_info torrent_file() {
    return new torrent_info(libtorrent_jni.torrent_torrent_file(swigCPtr, this), true);
  }

  public torrent_info get_torrent_copy() {
    long cPtr = libtorrent_jni.torrent_get_torrent_copy(swigCPtr, this);
    return (cPtr == 0) ? null : new torrent_info(cPtr, true);
  }

  public String uuid() {
    return libtorrent_jni.torrent_uuid(swigCPtr, this);
  }

  public void set_uuid(String s) {
    libtorrent_jni.torrent_set_uuid(swigCPtr, this, s);
  }

  public String url() {
    return libtorrent_jni.torrent_url(swigCPtr, this);
  }

  public void set_url(String s) {
    libtorrent_jni.torrent_set_url(swigCPtr, this, s);
  }

  public String source_feed_url() {
    return libtorrent_jni.torrent_source_feed_url(swigCPtr, this);
  }

  public void set_source_feed_url(String s) {
    libtorrent_jni.torrent_set_source_feed_url(swigCPtr, this, s);
  }

  public announce_entry_vector trackers() {
    return new announce_entry_vector(libtorrent_jni.torrent_trackers(swigCPtr, this), false);
  }

  public void replace_trackers(announce_entry_vector urls) {
    libtorrent_jni.torrent_replace_trackers(swigCPtr, this, announce_entry_vector.getCPtr(urls), urls);
  }

  public boolean add_tracker(announce_entry url) {
    return libtorrent_jni.torrent_add_tracker(swigCPtr, this, announce_entry.getCPtr(url), url);
  }

  public torrent_handle get_handle() {
    return new torrent_handle(libtorrent_jni.torrent_get_handle(swigCPtr, this), true);
  }

  public void write_resume_data(entry rd) {
    libtorrent_jni.torrent_write_resume_data(swigCPtr, this, entry.getCPtr(rd), rd);
  }

  public void read_resume_data(bdecode_node rd) {
    libtorrent_jni.torrent_read_resume_data(swigCPtr, this, bdecode_node.getCPtr(rd), rd);
  }

  public void seen_complete() {
    libtorrent_jni.torrent_seen_complete(swigCPtr, this);
  }

  public int time_since_complete() {
    return libtorrent_jni.torrent_time_since_complete(swigCPtr, this);
  }

  public int last_seen_complete() {
    return libtorrent_jni.torrent_last_seen_complete(swigCPtr, this);
  }

  public void move_storage(String save_path, int flags) {
    libtorrent_jni.torrent_move_storage(swigCPtr, this, save_path, flags);
  }

  public void rename_file(int index, String name) {
    libtorrent_jni.torrent_rename_file(swigCPtr, this, index, name);
  }

  public boolean ready_for_connections() {
    return libtorrent_jni.torrent_ready_for_connections(swigCPtr, this);
  }

  public boolean valid_metadata() {
    return libtorrent_jni.torrent_valid_metadata(swigCPtr, this);
  }

  public boolean are_files_checked() {
    return libtorrent_jni.torrent_are_files_checked(swigCPtr, this);
  }

  public boolean valid_storage() {
    return libtorrent_jni.torrent_valid_storage(swigCPtr, this);
  }

  public boolean set_metadata(String metadata_buf, int metadata_size) {
    return libtorrent_jni.torrent_set_metadata(swigCPtr, this, metadata_buf, metadata_size);
  }

  public int sequence_number() {
    return libtorrent_jni.torrent_sequence_number(swigCPtr, this);
  }

  public boolean seed_mode() {
    return libtorrent_jni.torrent_seed_mode(swigCPtr, this);
  }

  public void leave_seed_mode(boolean skip_checking) {
    libtorrent_jni.torrent_leave_seed_mode(swigCPtr, this, skip_checking);
  }

  public boolean all_verified() {
    return libtorrent_jni.torrent_all_verified(swigCPtr, this);
  }

  public boolean verifying_piece(int piece) {
    return libtorrent_jni.torrent_verifying_piece(swigCPtr, this, piece);
  }

  public void verifying(int piece) {
    libtorrent_jni.torrent_verifying(swigCPtr, this, piece);
  }

  public boolean verified_piece(int piece) {
    return libtorrent_jni.torrent_verified_piece(swigCPtr, this, piece);
  }

  public void verified(int piece) {
    libtorrent_jni.torrent_verified(swigCPtr, this, piece);
  }

  public boolean add_merkle_nodes(int_sha1_hash_map n, int piece) {
    return libtorrent_jni.torrent_add_merkle_nodes(swigCPtr, this, int_sha1_hash_map.getCPtr(n), n, piece);
  }

  public void lsd_announce() {
    libtorrent_jni.torrent_lsd_announce(swigCPtr, this);
  }

  public void update_last_upload() {
    libtorrent_jni.torrent_update_last_upload(swigCPtr, this);
  }

  public void set_apply_ip_filter(boolean b) {
    libtorrent_jni.torrent_set_apply_ip_filter(swigCPtr, this, b);
  }

  public boolean apply_ip_filter() {
    return libtorrent_jni.torrent_apply_ip_filter(swigCPtr, this);
  }

  public int_vector predictive_pieces() {
    return new int_vector(libtorrent_jni.torrent_predictive_pieces(swigCPtr, this), false);
  }

  public void predicted_have_piece(int index, int milliseconds) {
    libtorrent_jni.torrent_predicted_have_piece(swigCPtr, this, index, milliseconds);
  }

  public void clear_in_state_update() {
    libtorrent_jni.torrent_clear_in_state_update(swigCPtr, this);
  }

  public void dec_refcount(String purpose) {
    libtorrent_jni.torrent_dec_refcount(swigCPtr, this, purpose);
  }

  public void inc_refcount(String purpose) {
    libtorrent_jni.torrent_inc_refcount(swigCPtr, this, purpose);
  }

  public int refcount() {
    return libtorrent_jni.torrent_refcount(swigCPtr, this);
  }

  public void inc_num_connecting() {
    libtorrent_jni.torrent_inc_num_connecting(swigCPtr, this);
  }

  public void dec_num_connecting() {
    libtorrent_jni.torrent_dec_num_connecting(swigCPtr, this);
  }

  public boolean is_ssl_torrent() {
    return libtorrent_jni.torrent_is_ssl_torrent(swigCPtr, this);
  }

  public void set_ssl_cert(String certificate, String private_key, String dh_params, String passphrase) {
    libtorrent_jni.torrent_set_ssl_cert(swigCPtr, this, certificate, private_key, dh_params, passphrase);
  }

  public void set_ssl_cert_buffer(String certificate, String private_key, String dh_params) {
    libtorrent_jni.torrent_set_ssl_cert_buffer(swigCPtr, this, certificate, private_key, dh_params);
  }

  public int num_time_critical_pieces() {
    return libtorrent_jni.torrent_num_time_critical_pieces(swigCPtr, this);
  }

  public enum flags_t {
    overwrite_existing(libtorrent_jni.torrent_overwrite_existing_get());

    public final int swigValue() {
      return swigValue;
    }

    public static flags_t swigToEnum(int swigValue) {
      flags_t[] swigValues = flags_t.class.getEnumConstants();
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (flags_t swigEnum : swigValues)
        if (swigEnum.swigValue == swigValue)
          return swigEnum;
      throw new IllegalArgumentException("No enum " + flags_t.class + " with value " + swigValue);
    }

    @SuppressWarnings("unused")
    private flags_t() {
      this.swigValue = SwigNext.next++;
    }

    @SuppressWarnings("unused")
    private flags_t(int swigValue) {
      this.swigValue = swigValue;
      SwigNext.next = swigValue+1;
    }

    @SuppressWarnings("unused")
    private flags_t(flags_t swigEnum) {
      this.swigValue = swigEnum.swigValue;
      SwigNext.next = this.swigValue+1;
    }

    private final int swigValue;

    private static class SwigNext {
      private static int next = 0;
    }
  }

  public final static int error_file_none = libtorrent_jni.torrent_error_file_none_get();
  public final static int error_file_url = libtorrent_jni.torrent_error_file_url_get();
  public final static int error_file_ssl_ctx = libtorrent_jni.torrent_error_file_ssl_ctx_get();
  public final static int error_file_metadata = libtorrent_jni.torrent_error_file_metadata_get();

  public enum wasted_reason_t {
    piece_timed_out,
    piece_cancelled,
    piece_unknown,
    piece_seed,
    piece_end_game,
    piece_closing,
    waste_reason_max;

    public final int swigValue() {
      return swigValue;
    }

    public static wasted_reason_t swigToEnum(int swigValue) {
      wasted_reason_t[] swigValues = wasted_reason_t.class.getEnumConstants();
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (wasted_reason_t swigEnum : swigValues)
        if (swigEnum.swigValue == swigValue)
          return swigEnum;
      throw new IllegalArgumentException("No enum " + wasted_reason_t.class + " with value " + swigValue);
    }

    @SuppressWarnings("unused")
    private wasted_reason_t() {
      this.swigValue = SwigNext.next++;
    }

    @SuppressWarnings("unused")
    private wasted_reason_t(int swigValue) {
      this.swigValue = swigValue;
      SwigNext.next = swigValue+1;
    }

    @SuppressWarnings("unused")
    private wasted_reason_t(wasted_reason_t swigEnum) {
      this.swigValue = swigEnum.swigValue;
      SwigNext.next = this.swigValue+1;
    }

    private final int swigValue;

    private static class SwigNext {
      private static int next = 0;
    }
  }

}
